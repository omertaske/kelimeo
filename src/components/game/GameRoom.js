import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useGame } from '../../context/GameContext';
import { useSound } from '../../hooks/useSound';
import { toLowerCaseTurkish } from '../../helpers/stringHelpers';
import Toast from '../gameRoom/ui/Toast';
import GameEndScreen from '../gameRoom/ui/GameEndScreen';
import BagDrawer from '../gameRoom/ui/BagDrawer';
import BlankLetterModal from '../gameRoom/ui/BlankLetterModal';
import './GameRoom.css';
import './GameBoard.css';

const GameRoom = () => {
  const { roomId } = useParams();
  const navigate = useNavigate();
  const { 
    gameState, 
    GAME_STATES, 
    BOARD_TYPES,
    currentRoom,
    opponent,
    matchingTimer,
    gameTimer,
    turnTimer, // 60 saniye hamle s√ºresi
    currentTurn,
    playerLetters,
    gameBoard,
    score,
    makeMove,
    leaveGame,
    joinRoom,
    shuffleLetters,
    passMove,
    placedTiles,
    placeTile,
    removeTile,
    clearPlacedTiles,
    lastMove,
    moveHistory,
    LETTER_SCORES,
    wordMeanings,
    resetGame,
    tileBagSnapshot, // TEK ORTAK TILE BAG ‚Äî UI snapshot
    opponentLetters,
    calculateScore,
    findAllWords,
    updateUserStats,
    currentUser
  } = useGame();

  const [toastMessage, setToastMessage] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [draggingLetter, setDraggingLetter] = useState(null);
  const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 });
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [rackPosition, setRackPosition] = useState({ bottom: 20, left: '50%' });
  const [isDraggingRack, setIsDraggingRack] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [blankSelection, setBlankSelection] = useState(null); // { row, col } - Blank se√ßimi i√ßin
  const [currentScore, setCurrentScore] = useState(0); // Yerle≈ütirilen harflerin puanƒ±

  const { playSound } = useSound();

  // Component mount olduƒüunda odaya katƒ±l (SADECE eƒüer oyun ba≈ülamamƒ±≈üsa)
  useEffect(() => {
    // Eƒüer oyun zaten PLAYING durumundaysa, joinRoom √ßaƒüƒ±rma (multiplayer'dan gelindi)
    if (gameState === GAME_STATES.PLAYING) {
      console.log('Oyun zaten ba≈ülamƒ±≈ü, joinRoom atlandƒ±');
      return;
    }

    // URL'den gelen roomId'yi BOARD_TYPES key'i olarak kontrol et
    const boardKey = roomId?.toUpperCase();
    const boardExists = BOARD_TYPES[boardKey];
    
    if (!boardExists) {
      // Eƒüer key olarak bulunamadƒ±ysa, id olarak ara
      const boardById = Object.values(BOARD_TYPES).find(b => b.id === roomId);
      if (!boardById) {
        navigate('/rooms');
        return;
      }
    }

    // Eƒüer hen√ºz bu odaya katƒ±lmadƒ±ysak, katƒ±l
    if (!currentRoom || currentRoom.id !== roomId) {
      console.log(`GameRoom mount: ${roomId} odasƒ±na katƒ±lƒ±yor...`);
      joinRoom(roomId);
    }
  }, [roomId, navigate, joinRoom, currentRoom, BOARD_TYPES, gameState, GAME_STATES.PLAYING]);

  // Mouse move listener for dragging
  useEffect(() => {
    const handleMouseMove = (e) => {
      if (draggingLetter) {
        setCursorPosition({ x: e.clientX, y: e.clientY });
      }
    };

    if (draggingLetter) {
      window.addEventListener('mousemove', handleMouseMove);
      return () => window.removeEventListener('mousemove', handleMouseMove);
    }
  }, [draggingLetter]);

  // Matchmaking timer g√∂sterimi - artƒ±k kullanƒ±lmƒ±yor, e≈üle≈üme ekranƒ±nda g√∂steriliyor
  useEffect(() => {
    // Bo≈ü - matchmaking mesajlarƒ± e≈üle≈üme ekranƒ±nda g√∂steriliyor
  }, [gameState, matchingTimer, GAME_STATES.MATCHING]);

  // Hamle s√ºresini title'da g√∂ster
  useEffect(() => {
    if (gameState === GAME_STATES.PLAYING && turnTimer !== undefined) {
      const mins = Math.floor(turnTimer / 60);
      const secs = turnTimer % 60;
      const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
      document.title = `‚è±Ô∏è ${timeStr} - Kelimeo`;
    } else {
      document.title = 'Kelimeo - T√ºrk√ße Kelime Oyunu';
    }
    
    return () => {
      document.title = 'Kelimeo - T√ºrk√ße Kelime Oyunu';
    };
  }, [gameState, turnTimer, GAME_STATES.PLAYING]);

  // Oyun timer uyarƒ±larƒ± - artƒ±k kullanƒ±lmƒ±yor
  useEffect(() => {
    // Bo≈ü - timer uyarƒ±larƒ± ekranda g√∂r√ºn√ºyor
  }, [gameState, currentTurn, gameTimer, GAME_STATES.PLAYING]);

  // Yerle≈ütirilen harfler deƒüi≈ütiƒüinde puanƒ± hesapla
  useEffect(() => {
    if (placedTiles.length === 0) {
      setCurrentScore(0);
      return;
    }

    // Ge√ßici tahta olu≈ütur
    const tempBoard = gameBoard.map(row => row.map(cell => ({ ...cell })));
    placedTiles.forEach(({ letter, row, col, isBlank, repr }) => {
      tempBoard[row][col] = {
        ...tempBoard[row][col],
        letter: isBlank ? repr : letter,
        owner: 'player',
        isBlank: isBlank || false,
        value: isBlank ? 0 : (LETTER_SCORES[letter] || 0)
      };
    });

    // T√úM olu≈üan kelimeleri bul ve toplam puanƒ± hesapla
    try {
      const positions = placedTiles.map(({ row, col }) => ({ row, col }));
      
      // findAllWords kullanarak t√ºm kelimeleri bul (context'ten gelen fonksiyon)
      const formedWords = findAllWords ? findAllWords(tempBoard, positions) : [];
      
      if (formedWords.length === 0) {
        setCurrentScore(0);
        return;
      }
      
      // Her kelime i√ßin puan hesapla ve topla
      let totalScore = 0;
      for (const { word, positions: wordPositions } of formedWords) {
        if (word.length < 2) continue; // Tek harfler sayƒ±lmaz
        
        const scoreResult = calculateScore(word, wordPositions, gameBoard);
        totalScore += scoreResult.score;
      }
      
      // BINGO bonusu (7 harf kullanƒ±ldƒ±ysa)
      if (placedTiles.length === 7) {
        totalScore += 50;
      }
      
      setCurrentScore(totalScore);
    } catch (error) {
      console.error('Puan hesaplama hatasƒ±:', error);
      setCurrentScore(0);
    }
  }, [placedTiles, gameBoard, LETTER_SCORES, calculateScore, findAllWords]);

  // Bot pas ge√ßme bildirimi
  useEffect(() => {
    if (moveHistory && moveHistory.length > 0) {
      const lastMoveEntry = moveHistory[moveHistory.length - 1];
      
      // Bot pas ge√ßmi≈üse bildir (toast ile)
      if (lastMoveEntry.player === 'opponent' && lastMoveEntry.type === 'pass') {
        setToastMessage({ 
          text: 'ü§ñ Bot ge√ßerli hamle bulamadƒ± ve pas ge√ßti!', 
          type: 'info',
          duration: 2000
        });
        playSound('rakipOynadi', 0.4);
      } else if (lastMoveEntry.player === 'opponent' && lastMoveEntry.type === 'word') {
        // Bot kelime oynadƒ±
        playSound('rakipOynadi', 0.4);
      }
    }
  }, [moveHistory, playSound]);

  const handleLetterSelect = (letter) => {
    if (currentTurn !== 'player' || gameState !== GAME_STATES.PLAYING) return;
    
    // Harfi s√ºr√ºkleme moduna al
    setDraggingLetter(letter);
    
    // Sarƒ± toast mesajƒ± g√∂ster (1 saniye) + ses efekti
    setToastMessage({ text: `${letter} se√ßildi`, type: 'yellow', duration: 1000 });
    playSound('kelimeEklendi', 0.3);
  };

  const handleBoardClick = (row, col) => {
    const cell = gameBoard[row][col];
    const placedTile = placedTiles.find(t => t.row === row && t.col === col);
    
    // Eƒüer h√ºcrede onaylanmƒ±≈ü bir harf varsa ve oyun devam ediyorsa, kelime anlamƒ±nƒ± g√∂ster
    if (cell.letter && cell.owner && gameState === GAME_STATES.PLAYING) {
      const word = findWordAtCell(row, col);
      if (word && word.length >= 2) {
        // Eƒüer kelime anlamƒ± cachede varsa g√∂ster
        if (wordMeanings[word]) {
          // Mavi toast mesajƒ± olarak g√∂ster (5 saniye)
          setToastMessage({ 
            text: `üìñ ${word}: ${wordMeanings[word]}`, 
            type: 'blue',
            duration: 5000
          });
          playSound('toastKelimeAnlami', 0.4);
        } else {
          // TDK'dan anlamƒ± al
          fetchWordMeaning(word);
        }
      }
      return; // Kelime g√∂sterimi yapƒ±ldƒ±, yerle≈ütirme yapma
    }
    
    // Oyuncu sƒ±rasƒ± deƒüilse √ßƒ±k
    if (currentTurn !== 'player' || gameState !== GAME_STATES.PLAYING) return;
    
    // Eƒüer s√ºr√ºklenen harf varsa, yerle≈ütir
    if (draggingLetter) {
      // Sadece bo≈ü h√ºcrelere yerle≈ütir (onaylanmƒ±≈ü harflerin √ºzerine yazma)
      if (!cell.letter && !placedTile) {
        // Blank (*) joker ise modal a√ß
        if (draggingLetter === '*') {
          setBlankSelection({ row, col });
          setDraggingLetter(null);
        } else {
          placeTile(draggingLetter, row, col);
          setToastMessage({ text: `${draggingLetter} harfi yerle≈ütirildi`, type: 'yellow', duration: 1000 });
          setDraggingLetter(null);
        }
      } else if (cell.letter) {
        setToastMessage({ text: '‚ö†Ô∏è Bu h√ºcrede zaten onaylanmƒ±≈ü bir harf var!', type: 'error', duration: 2000 });
        playSound('toastUyari', 0.5);
        setDraggingLetter(null);
      }
      return;
    }
    
    // Sadece ge√ßici yerle≈ütirilen harfleri kaldƒ±rabilir
    // Onaylanmƒ±≈ü harfler (cell.letter && cell.owner) kaldƒ±rƒ±lamaz
    if (placedTile) {
      removeTile(row, col);
      // Geri alma toast'ƒ± kaldƒ±rƒ±ldƒ± - sessiz i≈ülem
    } else if (cell.letter && cell.owner) {
      // Onaylanmƒ±≈ü harfler uyarƒ±sƒ± kaldƒ±rƒ±ldƒ±
    }
  };

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().then(() => {
        setIsFullscreen(true);
      }).catch(() => {
        setToastMessage({ text: '‚ö†Ô∏è Tam ekran a√ßƒ±lamadƒ±', type: 'error', duration: 2000 });
        playSound('toastUyari', 0.5);
      });
    } else {
      document.exitFullscreen().then(() => {
        setIsFullscreen(false);
      });
    }
  };

  const handleBlankSelect = (letter) => {
    if (blankSelection) {
      const { row, col } = blankSelection;
      placeTile('*', row, col, letter); // Blank joker + repr
      setToastMessage({ text: `üÉè Joker "${letter}" harfini temsil ediyor`, type: 'success', duration: 2000 });
      playSound('toastBasarili', 0.6);
      setBlankSelection(null);
    }
  };

  const handleBlankCancel = () => {
    // Joker se√ßimi iptal edildi - sadece modal'ƒ± kapat, harf zaten rafta
    setBlankSelection(null);
  };

  const handleRackMouseDown = (e) => {
    if (e.target.closest('.letter-tile')) return; // Harf tƒ±klanƒ±yorsa drag yapma
    
    setIsDraggingRack(true);
    const rect = e.currentTarget.getBoundingClientRect();
    setDragOffset({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    });
  };

  const handleRackMouseMove = useCallback((e) => {
    if (!isDraggingRack) return;
    
    const newLeft = e.clientX - dragOffset.x;
    const newTop = e.clientY - dragOffset.y;
    
    setRackPosition({
      left: newLeft,
      top: newTop,
      bottom: 'auto'
    });
  }, [isDraggingRack, dragOffset]);

  const handleRackMouseUp = useCallback(() => {
    setIsDraggingRack(false);
  }, []);

  // Rack drag i√ßin global event listener
  useEffect(() => {
    if (isDraggingRack) {
      window.addEventListener('mousemove', handleRackMouseMove);
      window.addEventListener('mouseup', handleRackMouseUp);
      return () => {
        window.removeEventListener('mousemove', handleRackMouseMove);
        window.removeEventListener('mouseup', handleRackMouseUp);
      };
    }
  }, [isDraggingRack, handleRackMouseMove, handleRackMouseUp]);

  const handleSubmitWord = async () => {
    if (placedTiles.length === 0 || isSubmitting) return;
    
    setIsSubmitting(true);
    setToastMessage({ text: 'Kelime kontrol ediliyor...', type: 'info', duration: 2000 });

    const positions = placedTiles.map(({ row, col }) => ({ row, col }));

    try {
      const result = await makeMove('', positions);
      
      if (result.success) {
        const wordsText = result.words.map(w => w.word).join(', ');
        let successMessage = `‚úÖ Harika! "${wordsText}" - ${result.score} puan!`;
        
        if (placedTiles.length === 7) {
          successMessage += ' üéâ BINGO! +50 bonus puan!';
        }
        
        setToastMessage({ text: successMessage, type: 'success', duration: 3000 });
        playSound('kelimeKabulEdildi', 0.6);
        setCurrentScore(0); // Puanƒ± sƒ±fƒ±rla
      } else {
        setToastMessage({ text: `‚ùå ${result.error}`, type: 'error', duration: 3000 });
        playSound('toastUyari', 0.5);
        clearPlacedTiles();
        setCurrentScore(0); // Puanƒ± sƒ±fƒ±rla
      }
    } catch (error) {
      setToastMessage({ text: '‚ùå Bir hata olu≈ütu!', type: 'error', duration: 2000 });
      playSound('toastUyari', 0.5);
      clearPlacedTiles();
      setCurrentScore(0); // Puanƒ± sƒ±fƒ±rla
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleShuffle = () => {
    shuffleLetters();
    setToastMessage({ text: 'üîÄ Harfler karƒ±≈ütƒ±rƒ±ldƒ±!', type: 'info', duration: 1000 });
  };

  const handlePass = () => {
    const result = passMove();
    if (result.success) {
      setToastMessage({ text: '‚è≠Ô∏è Sƒ±ra ge√ßildi!', type: 'info', duration: 2000 });
    } else {
      setToastMessage({ text: `‚ùå ${result.error}`, type: 'error', duration: 2000 });
      playSound('toastUyari', 0.5);
    }
  };

  const handleClear = () => {
    clearPlacedTiles();
    setToastMessage({ text: 'üóëÔ∏è Yerle≈ütirilen harfler temizlendi!', type: 'info', duration: 1000 });
  };

  // TDK'dan kelime anlamƒ±nƒ± √ßek
  const fetchWordMeaning = async (word) => {
    try {
      setToastMessage({ text: 'üìñ Kelime anlamƒ± getiriliyor...', type: 'info', duration: 1000 });
      
      const response = await fetch(
        `https://sozluk.gov.tr/gts?ara=${encodeURIComponent(toLowerCaseTurkish(word))}`
      );
      
      if (!response.ok) {
        setToastMessage({ text: '‚ùå Kelime anlamƒ± alƒ±namadƒ±!', type: 'error', duration: 2000 });
        playSound('toastUyari', 0.5);
        return;
      }

      const data = await response.json();
      
      if (!data || data.error || !Array.isArray(data) || data.length === 0) {
        setToastMessage({ text: `‚ùå "${word}" kelimesinin anlamƒ± bulunamadƒ±!`, type: 'error', duration: 2000 });
        playSound('toastUyari', 0.5);
        return;
      }

      const meaning = data[0]?.anlamlarListe?.[0]?.anlam || 'Anlam bulunamadƒ±';
      
      // Mavi toast mesajƒ± olarak g√∂ster (5 saniye)
      setToastMessage({ 
        text: `üìñ ${word}: ${meaning}`, 
        type: 'blue',
        duration: 5000
      });
      playSound('toastKelimeAnlami', 0.4);
      
    } catch (error) {
      console.error('TDK API error:', error);
      setToastMessage({ text: '‚ùå Baƒülantƒ± hatasƒ±!', type: 'error', duration: 2000 });
      playSound('toastUyari', 0.5);
    }
  };

  // H√ºcredeki kelimeyi bul (yatay veya dikey)
  const findWordAtCell = (row, col) => {
    if (!gameBoard[row] || !gameBoard[row][col] || !gameBoard[row][col].letter) {
      return null;
    }

    // Yatay kelime bul
    let startCol = col;
    let endCol = col;
    
    // Ba≈ülangƒ±cƒ± bul
    while (startCol > 0 && gameBoard[row][startCol - 1]?.letter) {
      startCol--;
    }
    
    // Biti≈üi bul
    while (endCol < gameBoard[row].length - 1 && gameBoard[row][endCol + 1]?.letter) {
      endCol++;
    }
    
    // Yatay kelime olu≈ütur
    let horizontalWord = '';
    for (let c = startCol; c <= endCol; c++) {
      horizontalWord += gameBoard[row][c].letter;
    }
    
    // Dikey kelime bul
    let startRow = row;
    let endRow = row;
    
    // Ba≈ülangƒ±cƒ± bul
    while (startRow > 0 && gameBoard[startRow - 1]?.[col]?.letter) {
      startRow--;
    }
    
    // Biti≈üi bul
    while (endRow < gameBoard.length - 1 && gameBoard[endRow + 1]?.[col]?.letter) {
      endRow++;
    }
    
    // Dikey kelime olu≈ütur
    let verticalWord = '';
    for (let r = startRow; r <= endRow; r++) {
      verticalWord += gameBoard[r][col].letter;
    }
    
    // En az 2 harfli kelimeyi d√∂nd√ºr
    if (horizontalWord.length >= 2) {
      return horizontalWord;
    } else if (verticalWord.length >= 2) {
      return verticalWord;
    }
    
    return null;
  };

  // H√ºcreye hover olduƒüunda - kelime anlamƒ± varsa g√∂ster
  const handleCellHover = (row, col) => {
    const cell = gameBoard[row]?.[col];
    if (!cell || !cell.letter || !cell.owner) return; // Sadece onaylanmƒ±≈ü harfler i√ßin
    
    // Hover efekti i√ßin kullanƒ±labilir (≈üimdilik bo≈ü)
  };

  const handleLeaveGame = () => {
    if (gameState === GAME_STATES.PLAYING) {
      if (window.confirm('Oyundan √ßƒ±kmak istediƒüinize emin misiniz? Bu durum yenilgi sayƒ±lacaktƒ±r!')) {
        // Yarƒ±da bƒ±rakma = maƒülubiyet
        if (currentUser && opponent) {
          updateUserStats(currentUser.id, {
            gamesPlayed: 1,
            losses: 1
          });
          console.log('‚ùå Oyun yarƒ±da bƒ±rakƒ±ldƒ± - maƒülubiyet kaydedildi');
        }
        
        leaveGame();
        navigate('/rooms');
      }
    } else {
      navigate('/rooms');
    }
  };

  const getBoardCellClass = (row, col, cell) => {
    let classes = ['board-cell'];
    
    // Premium kare tipleri
    if (cell.multiplier) {
      classes.push(cell.multiplier);
    }
    
    if (cell.isCenter && !cell.letter) {
      classes.push('center-cell');
    }
    
    // Harf durumu
    if (cell.letter) {
      classes.push('filled');
      if (cell.owner === 'player') classes.push('player-tile');
      else if (cell.owner === 'opponent') classes.push('opponent-tile');
      
      // Blank joker kontrol√º
      if (cell.isBlank) {
        classes.push('blank-tile');
      }
    }
    
    // Ge√ßici yerle≈ütirilmi≈ü harf (blank kontrol√º)
    const placedTile = placedTiles.find(t => t.row === row && t.col === col);
    if (placedTile) {
      classes.push('placed');
      if (placedTile.isBlank) {
        classes.push('blank-tile');
      }
    }
    
    // Son hamle vurgusu
    if (lastMove && lastMove.positions.some(p => p.row === row && p.col === col)) {
      classes.push('last-move-highlight');
    }
    
    return classes.join(' ');
  };

  const renderBoard = () => {
    if (!currentRoom || !gameBoard.length) return null;

    const size = currentRoom.boardSize;
    
    return (
      <div className="game-board-container">
        {/* Fullscreen Toggle Button */}
        <button 
          className="fullscreen-toggle"
          onClick={toggleFullscreen}
          title={isFullscreen ? "Tam ekrandan √ßƒ±k" : "Tam ekran"}
        >
          {isFullscreen ? 'üóô' : '‚õ∂'}
        </button>

        {/* Dragging Letter Following Cursor */}
        {draggingLetter && (
          <div 
            className="letter-tile dragging"
            style={{
              left: `${cursorPosition.x - 25}px`,
              top: `${cursorPosition.y - 25}px`
            }}
          >
            {draggingLetter}
            <span className="letter-tile-score">{LETTER_SCORES[draggingLetter] || 0}</span>
          </div>
        )}

        <div className="game-board" style={{ 
          gridTemplateColumns: `repeat(${size}, 1fr)`,
          gridTemplateRows: `repeat(${size}, 1fr)`
        }}>
          {gameBoard.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
              const placedTile = placedTiles.find(t => t.row === rowIndex && t.col === colIndex);
              const displayLetter = placedTile ? placedTile.letter : cell.letter;
              
              return (
                <div
                  key={`${rowIndex}-${colIndex}`}
                  className={getBoardCellClass(rowIndex, colIndex, cell)}
                  onClick={() => handleBoardClick(rowIndex, colIndex)}
                  onMouseEnter={() => handleCellHover(rowIndex, colIndex)}
                  onMouseLeave={() => {}}
                  title={cell.multiplier || ''}
                  style={{ 
                    cursor: draggingLetter ? 'crosshair' : 'pointer',
                    position: 'relative'
                  }}
                >
                  {displayLetter ? (
                    <>
                      <span className="cell-letter">{displayLetter}</span>
                      <span className="cell-score">{LETTER_SCORES[displayLetter] || 0}</span>
                    </>
                  ) : cell.isCenter ? (
                    <span className="center-star">‚≠ê</span>
                  ) : cell.multiplier ? (
                    <span className="cell-multiplier">
                      {cell.multiplier === 'TW' ? '√ó3' : 
                       cell.multiplier === 'DW' ? '√ó2' : 
                       cell.multiplier === 'TL' ? '√ó3' : 
                       cell.multiplier === 'DL' ? '√ó2' : cell.multiplier}
                    </span>
                  ) : null}
                </div>
              );
            })
          )}
        </div>
        
        {/* Letter Rack - Floating & Draggable */}
        <div 
          className={`letter-rack ${isDraggingRack ? 'dragging' : ''}`}
          style={{
            position: 'fixed',
            left: rackPosition.left,
            top: rackPosition.top,
            bottom: rackPosition.bottom,
            transform: rackPosition.bottom !== 'auto' ? 'translateX(-50%)' : 'none',
            cursor: isDraggingRack ? 'grabbing' : 'grab'
          }}
          onMouseDown={handleRackMouseDown}
        >
          <div className="letter-rack-title">
            ‚úã Harfleriniz ({playerLetters.length}/7) {draggingLetter ? '- S√ºr√ºkleniyor...' : isDraggingRack ? '- Ta≈üƒ±nƒ±yor...' : ''}
          </div>
          <div className="letter-tiles">
            {playerLetters.map((letter, index) => (
              <div
                key={`${letter}-${index}`}
                className={`letter-tile ${draggingLetter === letter ? 'selected' : ''} ${currentTurn !== 'player' ? 'disabled' : ''}`}
                onClick={() => handleLetterSelect(letter)}
                style={{ cursor: currentTurn === 'player' ? 'grab' : 'not-allowed' }}
              >
                {letter}
                <span className="letter-tile-score">{LETTER_SCORES[letter] || 0}</span>
              </div>
            ))}
          </div>
          
          {/* Kontrol Butonlarƒ± */}
          <div className="rack-controls">
            <button
              className="control-button primary"
              onClick={handleSubmitWord}
              disabled={placedTiles.length === 0 || currentTurn !== 'player' || isSubmitting}
            >
              ‚úÖ G√∂nder
            </button>
            
            <button
              className="control-button secondary"
              onClick={handleClear}
              disabled={placedTiles.length === 0}
            >
              ÔøΩÔ∏è Temizle
            </button>
            
            <button
              className="control-button secondary"
              onClick={handleShuffle}
              disabled={currentTurn !== 'player'}
            >
              ÔøΩ Karƒ±≈ütƒ±r
            </button>
            
            <button
              className="control-button secondary"
              onClick={handlePass}
              disabled={currentTurn !== 'player'}
            >
              ‚è≠Ô∏è Pas
            </button>
          </div>
        </div>
      </div>
    );
  };

  // roomId'yi hem uppercase key hem de id olarak kontrol et
  const currentBoardType = BOARD_TYPES[roomId?.toUpperCase()] || 
                          Object.values(BOARD_TYPES).find(b => b.id === roomId);

  if (!currentBoardType) {
    return (
      <div className="game-room error">
        <h2>‚ùå Oda bulunamadƒ±!</h2>
        <button onClick={() => navigate('/rooms')}>Odalara D√∂n</button>
      </div>
    );
  }

  if (gameState === GAME_STATES.MATCHING) {
    return (
      <div className="game-room matching">
        <div className="matching-screen">
          <div className="room-info">
            <h2>üéØ {currentBoardType.name}</h2>
            <p>{currentBoardType.description}</p>
          </div>
          
          <div className="matching-animation">
            <div className="spinner"></div>
            <h3>üîç Rakip Arƒ±yor...</h3>
            <p className="timer-text">
              {matchingTimer <= 10 
                ? `${10 - matchingTimer}s kaldƒ±` 
                : 'Bot ile e≈üle≈üiliyor...'}
            </p>
            <div className="progress-bar">
              <div 
                className="progress-fill" 
                style={{ width: `${(matchingTimer / 10) * 100}%` }}
              ></div>
            </div>
          </div>

          <button className="cancel-button" onClick={handleLeaveGame}>
            ‚ùå ƒ∞ptal Et
          </button>
        </div>
      </div>
    );
  }

  if (gameState === GAME_STATES.PLAYING) {
    return (
      <div className="game-room playing">
        {/* Game Header */}
        <div className="game-header">
          <div className="room-title">
            <h2>{currentBoardType.icon} {currentBoardType.name}</h2>
          </div>
          
          <div className="game-info">
            <div className="timer-section">
              <div className={`game-timer ${gameTimer <= 10 ? 'urgent' : gameTimer <= 30 ? 'warning' : ''}`}>
                ‚è∞ {Math.floor(gameTimer / 60)}:{(gameTimer % 60).toString().padStart(2, '0')}
              </div>
              <div className={`turn-timer ${turnTimer <= 10 ? 'urgent' : turnTimer <= 20 ? 'warning' : ''}`}>
                ‚è±Ô∏è Hamle: {turnTimer}s
              </div>
              <div className="turn-indicator">
                {currentTurn === 'player' ? 'üéØ Sizin sƒ±ranƒ±z' : 'ü§ñ Rakip oynuyor'}
              </div>
            </div>
            
            <div className="score-section">
              <div className="score-board">
                <div className="player-score">
                  <span className="score-label">üë§ Sen</span>
                  <span className="score-value">{score.player}</span>
                  <span className="letter-count">üé¥ {playerLetters.length} harf</span>
                </div>
                <div className="vs-separator">VS</div>
                <div className="opponent-score">
                  <span className="score-label">{opponent?.isBot ? 'ü§ñ' : 'üë§'} {opponent?.username}</span>
                  <span className="score-value">{score.opponent}</span>
                  <span className="letter-count">üé¥ {opponentLetters.length} harf</span>
                </div>
              </div>
              <div className="bag-info">
                üì¶ Torbada: {tileBagSnapshot ? Object.values(tileBagSnapshot).reduce((sum, tile) => sum + tile.remaining, 0) : 0} harf
              </div>
            </div>
            
            <button className="leave-button" onClick={handleLeaveGame}>
              üö™ √áƒ±kƒ±≈ü
            </button>
          </div>
        </div>

        {/* Toast Messages */}
        {toastMessage && (
          <Toast 
            message={toastMessage.text}
            type={toastMessage.type}
            duration={toastMessage.duration || 3000}
            onClose={() => setToastMessage(null)}
          />
        )}

        {/* Bag Drawer - TEK ORTAK TILE BAG */}
        <BagDrawer tileBagSnapshot={tileBagSnapshot} />

        {/* Blank Letter Selection Modal */}
        {blankSelection && (
          <BlankLetterModal
            onSelect={handleBlankSelect}
            onCancel={handleBlankCancel}
          />
        )}

        {/* Score Star - Sol Alt K√∂≈üe */}
        {currentScore > 0 && (
          <div className="score-star">
            <div className="star-icon">‚≠ê</div>
            <div className="star-score">{currentScore}</div>
          </div>
        )}

        {/* Game Content */}
        <div className="game-content">
          {/* Game Board - Full Width */}
          <div className="board-section full-width">
            {renderBoard()}
          </div>
        </div>
      </div>
    );
  }

  if (gameState === GAME_STATES.FINISHED) {
    const isWin = score.player > score.opponent;
    
    return (
      <div className="game-room finished">
        <GameEndScreen
          isWin={isWin}
          playerScore={score.player}
          opponentScore={score.opponent}
          onClose={() => {
            resetGame();
            navigate('/rooms');
          }}
          onRematch={() => {
            resetGame();
            // Aynƒ± odaya tekrar katƒ±l
            if (currentRoom) {
              joinRoom(currentRoom.id);
            }
          }}
        />
      </div>
    );
  }

  return (
    <div className="game-room waiting">
      <h2>‚è≥ Oyun hazƒ±rlanƒ±yor...</h2>
      <button onClick={handleLeaveGame}>üîô Geri D√∂n</button>
    </div>
  );
};

export default GameRoom;